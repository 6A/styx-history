//! This module defines the `Architecture` enum, and all the instructions declared for each
//! architecture.
//!
//! Code for instruction matching is generated by a Python script during the build.

#![allow(non_upper_case_globals)]

use builder::{Builder, Value, ValueKind};
use emit::Emitter;

use std::fmt::{self, Display, Formatter};
use std::mem;

#[allow(unused_imports)]
use byteorder::{NativeEndian, WriteBytesExt};


/// Informations about the current usage of the registers.
pub type RegistersState = u128;

/// Informations about the current usage of the stack.
pub type StackState = u32;


// //==========================================================================//
// // OPERAND                                                                  //
// //==========================================================================//

bitflags! {
    /// The definition of an operand.
    pub struct OpDef: u32 {
        /// Operand is null.
        const Null      = 0b0_0000_0000;
        /// Operand is a register.
        const Register  = 0b0_0000_0001;
        /// Operand is on the stack.
        const Stack     = 0b0_0000_0010;
        /// Operand is in the memory.
        const Memory    = 0b0_0000_0100;
        /// Operand is an immediate value.
        const Immediate = 0b0_0000_1000;
        /// Operand is a relative offset to next instruction.
        const Relative  = 0b0_0001_0000;
    }
}

/// The architecture-specific location of an operand.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum OperandLocation {
    /// The value does not exist.
    Null,

    /// The value is stored on the register.
    Register(u16),

    /// The value is stored on the stack.
    Stack(u16),

    /// The value is stored somewhere in the memory.
    Memory(u64),

    /// The value is immediate (or constant).
    Immediate(u128),

    /// The value represents a relative address.
    Relative(i64)
}

/// A parameter passed to a `Proc`.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct Operand {
    /// Location (stack or register) of the parameter.
    pub location: OperandLocation,

    /// Size (in bytes) of the operand.
    pub size: u16
}

impl Operand {
    /// Creates a new operand, given its size in bytes and location.
    #[inline]
    pub fn new(size: u16, location: OperandLocation) -> Self {
        Operand { size, location }
    }

    /// Creates a new null operand, with a null size and location.
    #[inline]
    pub fn null() -> Self {
        Operand { size: 0, location: OperandLocation::Null }
    }

    /// Returns the size of the data the operand represents.
    #[inline]
    pub fn size(&self) -> u16 {
        self.size
    }

    /// Returns a mutable reference to the raw data of the operand.
    ///
    /// # Panics
    /// The operand isn't a register.
    pub fn raw(&mut self) -> &mut u16 {
        match &mut self.location {
            &mut OperandLocation::Register(ref mut r) => r,
            _ => panic!("Operand::raw() can only be called on register operands.")
        }
    }

    /// Returns a "definition" of this operand.
    #[inline]
    pub fn definition(&self) -> OpDef {
        use self::OperandLocation::*;

        match self.location {
            Null                 => OpDef::Null,
            Register(_)          => OpDef::Register,
            Stack(_) | Memory(_) => OpDef::Memory,
            Immediate(_)         => OpDef::Immediate,
            Relative(_)          => OpDef::Relative
        }
    }

    /// Returns the register represented by this operand,
    /// if it does represent a register.
    #[inline]
    pub fn get_register(&self) -> Option<u16> {
        if let OperandLocation::Register(reg) = self.location {
            Some(reg)
        } else {
            None
        }
    }
}

impl Display for Operand {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        use self::OperandLocation::*;

        match self.location {
            Null            => Ok(()),
            Register(reg)   => write!(f, "@{:03b}", reg),
            Stack(offset)   => write!(f, "(stack -{:#X})", offset),
            Memory(addr)    => write!(f, "[{:#X}]", addr),
            Immediate(imm)  => write!(f, "{:#X}", imm),
            Relative(rel)   => write!(f, "[{:#X}]", rel)
        }
    }
}


// //==========================================================================//
// // ARCHITECTURE                                                             //
// //==========================================================================//

/// Defines the target architecture of a compilation.
#[derive(Eq, PartialEq, Debug, Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum Architecture {
    /// ARM architecture.
    ARM,
    /// x86 architecture.
    X86,
    /// x86-64 architecture.
    X86_64
}

use self::Architecture::*;

impl Architecture {
    /// Returns the current architecture, or `None` if the current architecture is not supported.
    #[inline]
    pub fn current() -> Option<Architecture> {
        match ::std::env::consts::ARCH {
            "arm"    => Some(ARM),
            "x86"    => Some(X86),
            "x86_64" => Some(X86_64),
            _        => None
        }
    }

    /// Encodes the specified instruction.
    pub fn encode_instr(&self, name: &str, op1: Operand, op2: Operand, op3: Operand, emitter: &mut Emitter) -> bool {
        match *self {
            X86 | X86_64 => x86::encode_instr(name, op1, op2, op3, emitter),
            _ => unimplemented!()
        }
    }

    /// Returns the default `RegistersState` for this architecture.
    pub fn default_state(&self) -> (RegistersState, StackState) {
        ((self.average_instruction_size() as usize * mem::size_of::<usize>()) as RegistersState, 0)
    }

    /// Returns a native operand that describes the given architecture-independant operand.
    ///
    /// Registers will be returned on priority, but stack offsets might be returned if no register
    /// is available.
    pub fn get_native_operand(&self, operand: &Value, rstate: &mut RegistersState, sstate: &mut StackState) -> Operand {
        let size = operand.size();

        match operand.kind() {
            ValueKind::Immediate(imm) => Operand::new(size, OperandLocation::Immediate(imm as _)),
            ValueKind::Memory(mem) => Operand::new(size, OperandLocation::Memory(mem)),

            ValueKind::Argument(_) | ValueKind::Variable(_, _) => match
                match *self {
                    X86 | X86_64 => x86::to_native(size, rstate),
                    _ => unimplemented!()
                }
            {
                Some(operand) => operand,
                None => {
                    *sstate += size as u32;
                    Operand::new(size as _, OperandLocation::Stack(*sstate as _))
                }
            },

            _ => unimplemented!()
        }
    }

    /// Returns the average instruction size on this platform.
    pub fn average_instruction_size(&self) -> u8 {
        match *self {
            ARM => 4,
            X86 | X86_64 => 8
        }
    }

    /// Returns the number of registers that can contain a value
    /// with the specified size in this architecture.
    pub fn registers_count(&self, size: u16) -> u16 {
        match (*self, size) {
            (ARM, n) if n <= 32     => 16,
            (X86, _) | (X86_64, _)  => 12,

            _ => 0
        }
    }

    /// Reduces common groups of instructions into specific instructions
    /// in the target architecture.
    pub fn reduce(&self, _builder: &mut Builder) {
        match *self {
            X86 | X86_64 | ARM => ()
        }
    }

    /// Returns the default return operand for the target architecture.
    pub fn default_return_operand(&self, size: u16) -> Operand {
        match *self {
            X86 | X86_64 => Operand::new(size, OperandLocation::Register(0)),
            _ => unimplemented!()
        }
    }
}

impl Default for Architecture {
    fn default() -> Self {
        Self::current().expect("The current architecture is not supported.")
    }
}

impl Display for Architecture {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.write_str(match *self {
            ARM     => "ARM",
            X86     => "x86",
            X86_64  => "x86-64"
        })
    }
}


// //==========================================================================//
// // ARCHITECTURE-SPECIFIC CODE                                               //
// //==========================================================================//

mod x86 {
    use super::*;
    use super::OperandLocation as Location;

    include!(concat!(env!("OUT_DIR"), "/x86.rs"));

    bitflags! {
        pub struct Reg: u128 {
            const AX = 0b0001;
            const CX = 0b0010;
            const DX = 0b0100;
            const BX = 0b1000;

            const SP = 0b0001_0000;
            const BP = 0b0010_0000;
            const SI = 0b0100_0000;
            const DI = 0b1000_0000;
        }
    }

    #[allow(if_not_else)]
    pub fn to_native(size: u16, rstate: &mut RegistersState) -> Option<Operand> {
        let mut reg = Reg::from_bits_truncate(*rstate);

        let flag = if !reg.contains(Reg::AX) {
            reg.set(Reg::AX, true);
            0b0000
        } else if !reg.contains(Reg::CX) {
            reg.set(Reg::CX, true);
            0b0001
        } else if !reg.contains(Reg::DX) {
            reg.set(Reg::DX, true);
            0b0010
        } else if !reg.contains(Reg::BX) {
            reg.set(Reg::BX, true);
            0b0011
        } else {
            return None
        };

        *rstate = reg.bits();

        Some(Operand::new(size, Location::Register(flag as _)))
    }

    fn encode_opcode(opcode: u64, emitter: &mut Emitter) {
        unsafe {
            let opcode: [u8; 8] = mem::transmute(opcode);

            let count = match (opcode[0], opcode[1], opcode[2]) {
                (0x0F, 0x01, _) | (0x0F, 0xAE, _) | (0x0F, 0x38, _) | (0x0F, 0x3A, _) => 3,
                (0x0F, _, _) => 2,
                (_, _, _) => 1
            };

            emitter.emit_bytes(&opcode[0..count]).expect("Could not emit opcode");
        }
    }

    fn encode_operand(operand: Operand, emitter: &mut Emitter) {
        match operand.location {
            Location::Null           => return,
            Location::Register(opc)  => {
                emitter.emit_byte(opc as u8)
            },
            Location::Stack(offset)  => {
                if offset < 128 {
                    emitter.emit_byte((256 - offset) as u8)
                } else {
                    emitter.write_int::<NativeEndian>(-(offset as i64), operand.size as _).map_err(Into::into)
                }
            },
            Location::Relative(rel) => {
                emitter.write_int::<NativeEndian>(rel as _, operand.size as _).map_err(Into::into)
            },
            Location::Immediate(val) => {
                emitter.write_int::<NativeEndian>(val as _, operand.size as _).map_err(Into::into)
            },
            Location::Memory(_addr) => unimplemented!()
        }
        .expect("Could not encode operand.");
    }

    pub fn encode_instr(mnemonic: &str, mut op1: Operand, mut op2: Operand, mut op3: Operand,
                        emitter: &mut Emitter)
                        -> bool {

        if mnemonic != "nop" {
            info!("{:#X}\t{} {} ({}), {} ({}), {} ({})", emitter.offset(), mnemonic, op1, op1.size, op2, op2.size, op3, op3.size);
        }

        // encode opcode
        let opcode = match get_opcode(mnemonic, &mut op1, &mut op2, &mut op3) {
            Some(opcode) => opcode,
            None => return false
        };


        // special opcodes
        match opcode {
            0xB0 | 0xB8 | 0x40 | 0x48 | 0x50 | 0x58 | 0x0FC8 => {
                encode_opcode(opcode + op1.get_register().unwrap() as u64, emitter);

                op1 = Operand::null();
            },
            opcode => encode_opcode(opcode, emitter)
        }

        // encode operands
        if let Some(r1) = op1.get_register() {
            if let Some(r2) = op2.get_register() {
                // registers can be encoded in a single byte
                let mut r = 0b1100_0000 + r1;
                r += r2 << 3;

                if r < u8::max_value() as u16 {
                    emitter.emit_byte(r as u8).expect("Could not emit byte.");

                    return true
                }
            }
        }

        encode_operand(op1, emitter);
        encode_operand(op2, emitter);
        encode_operand(op3, emitter);

        true
    }
}

mod arm {

}

