
API
===

This document contains a list of all functions implemented in Styx until now.
It was automatically generated by a tool, and may be incomplete.

### Legend
- :small_blue_diamond: Types
- :small_orange_diamond: Functions

## Styx
#### :small_blue_diamond: `Diagnostic : Type`
A diagnostic.

#### :small_blue_diamond: `DiagnosticSeverity : Type`
The severity of a [`Diagnostic`].

#### :small_orange_diamond: `Diagnostics : Concept`
Defines an object that can report diagnostics.

#### :small_orange_diamond: `HasError : () -> Boolean`
Returns false.

#### :small_orange_diamond: `HasError : List Diagnostic -> Boolean`
Returns whether a diagnostic has already been logged.

#### :small_orange_diamond: `Report : () -> Diagnostic -> ()`
Does nothing with a diagnostic.

#### :small_orange_diamond: `Report : List Diagnostic -> Diagnostic -> List Diagnostic`
Adds the given diagnostic to the list of diagnostics.

#### :small_orange_diamond: `Severity : DiagnosticSeverity`


## Styx.Backends
#### :small_orange_diamond: `Backend : Concept`
Defines a Styx backend.

## Styx.Backends.Assembly
#### :small_blue_diamond: `AssemblyBackend : Type`
The assembly backend.

#### :small_orange_diamond: `AssemblySyntax : Syntax`
The assembly syntax.

## Styx.Parse
#### :small_blue_diamond: `Span : Type`
The span of a [`Token`] in its source input.

#### :small_blue_diamond: `Token : Type`
A token of Styx code.

#### :small_orange_diamond: `Lex : String -> Int -> Token [ diagnostics ::: Diagnostics ]`
A type which transforms

#### :small_orange_diamond: `Start : Int, Length : Int }`


## System
#### :small_blue_diamond: `Boolean : Type`
A boolean.

#### :small_blue_diamond: `Byte : Type`
A byte.

#### :small_blue_diamond: `I16 : Type`
A 16-bits signed integer.

#### :small_blue_diamond: `I32 : Type`
A 32-bits signed integer.

#### :small_blue_diamond: `I64 : Type`
A 64-bits signed integer.

#### :small_blue_diamond: `Int : Type`
A signed integer with a default size.

#### :small_blue_diamond: `Pair : Type -> Type -> Type`
A pair.

#### :small_blue_diamond: `Ptr : Type -> Type`
A pointer to a value. It cannot be null.

#### :small_blue_diamond: `Ptr : Type -> Type`
A pointer to an object of the specified type.

#### :small_blue_diamond: `String : Type`
An immutable string stored on the heap.

#### :small_blue_diamond: `StringBuffer : Type`
A mutable and growable string stored on the heap.

#### :small_blue_diamond: `Triple : Type -> Type -> Type -> Type`
A triple.

#### :small_blue_diamond: `Tuple : [Type] -> Type`
A n-elements tuple.

#### :small_blue_diamond: `U16 : Type`
A 16-bits unsigned integer.

#### :small_blue_diamond: `U32 : Type`
A 32-bits unsigned integer.

#### :small_blue_diamond: `U64 : Type`
A 64-bits unsigned integer.

#### :small_blue_diamond: `UInt : Type`
A unsigned integer with a default size.

#### :small_orange_diamond: `and : Boolean -> Boolean -> Boolean`
Logical 'or'.
 Logical 'and'.

#### :small_orange_diamond: `not : Boolean -> Boolean`
Logical 'not'.

#### :small_orange_diamond: `Offset : Ptr a -> Int -> Ptr a`
Returns a new pointer pointing at the given offset, relative to its original location.

#### :small_orange_diamond: `or : Boolean -> Boolean -> Boolean`
Logical 'not'.
 Logical 'or'.

#### :small_orange_diamond: `ParseRest : Syntax Expression`


#### :small_orange_diamond: `Read : Ptr a -> a`
Reads the value pointed to by the pointer.

#### :small_orange_diamond: `SizeOf : Type -> Int`
Returns the size of the given value.

#### :small_orange_diamond: `To : Ptr a -> Int`
Casts the pointer to an integer.

#### :small_orange_diamond: `To : Int -> Ptr a`
Casts the integer to a pointer.

#### :small_orange_diamond: `TuplePattern : Pattern`
A tuple pattern.

#### :small_orange_diamond: `TupleSyntax : Syntax Expression`
A tuple construction expression.

#### :small_orange_diamond: `xor : Boolean -> Boolean -> Boolean`
Logical 'and'.
 Logical 'xor'.

## System.Collections
#### :small_blue_diamond: `List : Type -> Type`
A chained list.

#### :small_blue_diamond: `Vec : Type -> Type -> Type`
A static vector stored on the heap.

#### :small_orange_diamond: `:: : a -> List a -> List a`
Prepends an element to a list.

#### :small_orange_diamond: `@ : List a -> List a -> List a`
Merges two lists together.

#### :small_orange_diamond: `Empty : Vec a 0`
Creates a new empty vector.

#### :small_orange_diamond: `Head : List a -> a`
Returns the head of the list.

#### :small_orange_diamond: `Head : Vec a (1 ..) -> a`
Gets the first item of the vector.

#### :small_orange_diamond: `Length : List a -> Int`
Returns the length of the list.

#### :small_orange_diamond: `ListPattern : Pattern`
List destructuring.

#### :small_orange_diamond: `New : a -> Vec a 1`
Creates a new vector, given its only item.

#### :small_orange_diamond: `Nth : Vec a n -> (0 .. n) -> a`
Gets the item at the nth position of the vector.

#### :small_orange_diamond: `Pop : Vec a n -> a`
Pops the item at the end of the vector.

#### :small_orange_diamond: `Push : Vec a n -> a -> Vec a (n + 1)`
Pushes an item to the vector.

## System.Core
#### :small_blue_diamond: `Axiom : Type`
An axiom, which defines the instance of a type.

#### :small_blue_diamond: `ByRef : Type -> Type`
Indicates an argument passed by reference.
 This is the default behavior for non-copyable types.

#### :small_blue_diamond: `ByValue : Type -> Type`
Indicates an argument passed by value.
 This is the default behavior for copyable types.

#### :small_blue_diamond: `Concept : Type`
A concept, which defines what a type must be able to do.

#### :small_blue_diamond: `Lazy : Type -> Type`
Indicates a lazily-computed argument.

#### :small_blue_diamond: `Q : Type -> Type`
Indicates a quoted argument.

#### :small_orange_diamond: `assert : Q a -> ()`
Asserts that an expression matches the upcoming axioms.
 If the aforementioned axiom is not actually true, an exception
 will be thrown.

#### :small_orange_diamond: `assume : Q a -> ()`
Statically assumes that the given axiom is true.
 If the aforementioned axiom is not actually true, the program
 enters a UB state.

#### :small_orange_diamond: `maybe : (a -> b) -> Q a -> b?`
Tries to assert conditions on a type that cannot be ensured
 statically. If the conditions are true, the body is returned.
 Otherwise, `None` is returned.

#### :small_orange_diamond: `satisfies : Q a -> Boolean`
Returns whether the given expression matches the upcoming axioms.

## System.Environment
#### :small_orange_diamond: `Backend : String`
The string identifier of the current backend.

#### :small_orange_diamond: `BackendVersion : Int`
An integer that represents the version of the current backend.

#### :small_orange_diamond: `PointerSize : Int`
The size of a pointer on the target architecture.

## System.Foreign
#### :small_orange_diamond: `MakeForeign : String -> String -> a`
Creates a function that performs an FFI call.

## System.Foreign.C
#### :small_blue_diamond: `CFile : Type`
Represents a file.

#### :small_blue_diamond: `CString : Type`
Represents a C string.

#### :small_orange_diamond: `Exit : Int -> Never`
Exits the current program.

#### :small_orange_diamond: `Fclose : CFile -> Int`
Closes the given stream.

#### :small_orange_diamond: `Fgetc : Ptr () -> Int`
Gets a character from the stream.

#### :small_orange_diamond: `Fgets : CString -> Int -> CFile -> CString`
Gets a line from the stream.

#### :small_orange_diamond: `Fopen : CString -> CString -> CFile`
Opens the given file.

#### :small_orange_diamond: `Fputc : Int -> CFile -> Int`
Writes a character to the stream, and advances by one.

#### :small_orange_diamond: `Fputs : CString -> CFile -> Int`
Writes a string to the stream, and advances by its length.

#### :small_orange_diamond: `Free : UInt -> ()`
Frees some memory.

#### :small_orange_diamond: `Fwrite : Ptr () -> Int -> Int -> CFile -> Int`
Writes a block of data to the stream, and advances by the specified length.

#### :small_orange_diamond: `GetEnv : CString -> CString`
Gets an environment string.

#### :small_orange_diamond: `Malloc : Int -> UInt`
Allocates some memory.

## System.Memory
#### :small_orange_diamond: `Transmute : a -> b`
Interprets the given value as a value of another type.

